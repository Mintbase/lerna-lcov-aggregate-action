"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const glob_1 = __importDefault(require("glob"));
const n_readlines_1 = __importDefault(require("n-readlines"));
const path_1 = __importDefault(require("path"));
const printError = (err) => process.stderr.write(`${chalk_1.default.red(`${err}`)}\n`);
const printWarning = (message) => process.stderr.write(`${chalk_1.default.yellow(message)}\n`);
const printInfo = (message) => process.stdout.write(`${chalk_1.default.blue(message)}\n`);
const parseLernaConfig = (cwd) => {
    const lernaConfigPath = path_1.default.join(cwd, "lerna.json");
    if (!fs_1.default.existsSync(lernaConfigPath)) {
        throw new Error("Lerna configuration file `lerna.json' does not exist");
    }
    return JSON.parse(fs_1.default.readFileSync(lernaConfigPath).toString("utf-8"));
};
const getPackageName = (absolutePackagePath) => {
    const packageJsonPath = path_1.default.join(absolutePackagePath, "package.json");
    let name;
    if (fs_1.default.existsSync(packageJsonPath)) {
        try {
            name = JSON.parse(fs_1.default.readFileSync(packageJsonPath).toString("utf-8")).name;
        }
        catch (err) {
            printError(err);
            process.exit(1);
        }
    }
    else {
        printWarning(`No \`package.json' found in \`${absolutePackagePath}'.`);
    }
    return name !== null && name !== void 0 ? name : "unknown package";
};
const processPackage = (cwd, relativePackagePath) => {
    const absolutePackagePath = path_1.default.join(cwd, relativePackagePath);
    const packageName = getPackageName(absolutePackagePath);
    const lcovInfoPath = path_1.default.join(absolutePackagePath, "coverage", "lcov.info");
    const result = [];
    if (!fs_1.default.existsSync(lcovInfoPath)) {
        printWarning(`No \`lcov.info' found for \`${packageName}'.`);
        return undefined;
    }
    printInfo(`Processing \`${packageName}'...`);
    const lineReader = new n_readlines_1.default(lcovInfoPath);
    let lineBuffer;
    while ((lineBuffer = lineReader.next())) {
        const line = lineBuffer.toString("utf-8");
        const match = /^SF:(.+)$/.exec(line);
        if (match) {
            result.push(`SF:${path_1.default.posix.join(...relativePackagePath.split(path_1.default.sep), match[1])}`);
        }
        else {
            result.push(line);
        }
    }
    return result;
};
const aggregateResults = (cwd, results) => {
    const outputDir = path_1.default.join(cwd, "coverage");
    const outputFile = path_1.default.join(outputDir, "lcov.info");
    printInfo(`Creating \`${outputFile}'...`);
    if (!fs_1.default.existsSync(outputDir)) {
        fs_1.default.mkdirSync(outputDir);
    }
    fs_1.default.open(outputFile, "w", (err, fd) => {
        if (err) {
            printError(err);
            return;
        }
        results.forEach((lines) => lines.forEach((line) => fs_1.default.writeSync(fd, `${line}\n`)));
        fs_1.default.closeSync(fd);
    });
};
const run = () => {
    const cwd = process.cwd();
    const { packages } = parseLernaConfig(cwd);
    const results = [];
    if (!packages) {
        process.stderr.write(`${chalk_1.default.red("No packages defined in `lerna.json'.")}\n`);
        process.exit(1);
    }
    packages.forEach((pattern) => {
        glob_1.default.sync(pattern, { cwd }).forEach((relativePackagePath) => {
            const result = processPackage(cwd, relativePackagePath);
            if (result) {
                results.push(result);
            }
        });
    });
    aggregateResults(cwd, results);
    process.stdout.write(`${chalk_1.default.green("Done!")}\n`);
};
exports.run = run;
